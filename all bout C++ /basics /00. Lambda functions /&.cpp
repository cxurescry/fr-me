// lambda функции

/*
(C++) 11 и выше
[](параметры){тело функции};
*/

const double pi = 3.14; 

#include <bits/stdc++.h>
using namespace std;

// фильтрация элементов в массиве 
void showArray(const int* arr, size_t length, bool (*filter_func)(int) = nullptr) {
	for (int i = 0; i < length; i++) {
		if (!nullptr) {
			if (filter_func(arr[i]))
				cout << arr[i] << " "
		}
		else 
			cout << arr[i] << " "; 
	} 
}	
 
int main() {

	// Примеры функций

	[](int a, int b){cout << "sum: " << a + b << "\n"}(10, 15); 

	auto r = [](int a, int b){return a + b};
	auto s = r;
	cout << r(10, 15) << " " << s(20, 40) << "\n";

	auto res3 {[](auto a, auto b) -> auto {return a + b}};


	int data[] {1, 2, 3, 4, 5, 6};
	showArray(data, sizeof(data) / sizeof(*data)); 
	// без последнего параметра функции (критерия отбора) будет выведен массив целиком
	showArray(data, sizeof(data) / sizeof(*data), [](int x){return x % 2});
	// таким образом мы прописали критерий через анонимую функцию


	// [] (захват переменных)
	
	int x = 13;
	auto r = [] () {
		cout << x << endl;
		cout << pi << endl;	
	};
	// в данном случае лямбда функция сможет получить доступ к глобальной переменной, 
	// в то время, как к локальной доступ получить не сможет.
	
	auto r = [=] () mutable {
		for (int& x: data) {
			x += 2;
			cout << x << " ";
		}
		// 3 4 5 6 7 8
		cout << "\n";
		cout << x << " "; // 13
		x++; |
		cout << x << endl // 14
	}
	for (int& x: data) {
		cout << x << " ";
	}
	// 1 2 3 4 5 6
	r();
	cout << x << "\n"; // 13	
	// "=" побуждает программу скопировать все значения локальных переменных в константные переменные
	// которые создаются внутри анонимной функции с идентичными именами
	// т.е "x" из ф-ии main и "x" из лямбды функции не одно и то же
	// "mutable" позволяет дополнительно разрешать изменение ТОЛЬКО ПЕРЕМЕННЫХ ВНУТРИ анонимных функций
	
	// можно вместо [=] прописать конкретные локальные переменные "[data]", к которым нужен доступ, к остальным переменным доступа не будет
	
	
	// для изменения локальных переменных вне анонимных функций нужно передавать переменные либо по ссылкам, либо через указатели
	
	// через ссылки (вместо [&] можно прописать конкретные переменные [&data, &x])
	auto r = [&] () { // mutable избыточен
		for (int& x: data) {
			x += 2;
			cout << x << " ";
		}
		// 3 4 5 6 7 8
		cout << "\n";
	}
	for (int& x : data) {
		cout << x << " ";
	}	// 3 4 5 6 7 8
	
	// через указатель
	int y = 10;
	int* ptr_y = &y;
	auto r = [ptr_y](){
		(*ptr_y)++;
	}
	r();
	cout << y << endl; // 11		
	return 0;
}

/*
доп. виды записей в []
1) [&a, b, &m, n] - b и n по значению, a и b по ссылке
2) [=, &m, &n] - m и n по ссылке, все по значению
3) [&, m, n] - m и n по значению, все по ссылке
*/
